---
title: "STATS 506 Group 4 Project"
author: "Huayu Li, Kai Liu, Xiru Lyu"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    toc: true
---
# Introduction

According to [Centers for Disease Control and Prevention](https://www.cdc.gov/cholesterol/facts.htm), in 2015-2016, more than 12% of adults at the age of 20 and above in the United States have cholesterol levels higher than 240mg/ml. A high cholesterol level is one of the major risk factors for coronary heart disease, heart attack and stroke. While there are two types of cholesterol, low-density lipoprotein (LDL) is known as the “bad” one that leads to the buildup of cholesterol in arteries. The goal of this project is to explore factors that can affect the level of LDL in a human body, and the result is intended to help readers gain insights on how to balance the level of LDL in order to control/prevent cardiovascular diseases.

The analysis result shows that age, weight, height, BMI, systolic and diastolic blood pressures, and the level of triglyceride are factors that can explain the variation in the level of LDL.


# Data

The data analysis is performed with the [NHANES 2015-2016 data](https://wwwn.cdc.gov/nchs/nhanes/ContinuousNhanes/Default.aspx?BeginYear=2015). The dependent variable, the level of low-density lipoprotein (LDL), measured by mg/dl, is selected from the dataset [Cholesterol - LDL & Triglycerides](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Laboratory&CycleBeginYear=2015) of the laboratory data. Since a high level of triglyceride is believed to be associated with a high level of LDL, it is included in the model as the independent variable. Triglyceride data is also obtained from [Cholesterol - LDL & Triglycerides](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Laboratory&CycleBeginYear=2015) of the laboratory data. We also include blood pressure readings from [Blood Pressure](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Examination&CycleBeginYear=2015) dataset of the examination data. According to the data description, some participants have multiple blood pressure readings. For simplicity, we use averaged systolic and diastolic blood pressure readings as blood pressure measurements for each individual. Averaged intakes of fat and cholesterol, computed using both the [First](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Dietary&CycleBeginYear=2015) and [the Second Day Total Nutrient Intakes](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Dietary&CycleBeginYear=2015) of the dietary data, are added as independent variables as well. To account for more individual differences, we also include gender, race and age from the [Demographics Data](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Demographics&CycleBeginYear=2015), and height, weight and BMI information from [Body Measures](https://wwwn.cdc.gov/nchs/nhanes/Search/DataPage.aspx?Component=Examination&CycleBeginYear=2015) of the examination data as additional covariates. Furthermore, SEQN, the respondent sequence number, is utilized as the unique identifier to match responses for each respondent. Finally, we removed all rows containing missing values, and there are a total of 2503 observations available for further analysis.

# Methods

We fit models using multiple linear regression techniques and then perform model selections to choose the model that best describes the level of LDL. For the very first model, we regress the dependent variable **LDL** on all predictors: 

$\mathbf{LDL}$ ~ $\mathbf{age + race + gender + height + weight + BMI + fat + cholesterol + triglyceride + diastolic + systolic}$ (1)

Note that covariates **gender** and **race** are treated as categorical variables.

A check of the relationship between residuals and fitted values suggests a transformation for the dependent variable. 

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align="center", fig.cap="Residual plot of the full model"}
library(png)
library(grid)
img <- readPNG("./Huayuli/Residual_plot.png")
 grid.raster(img)
```

With the help of the Box-Cox test: 

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align="center", fig.cap="Box-Cox Transformation plot"}
library(png)
library(grid)
img <- readPNG("./Huayuli/Boxcox.png")
 grid.raster(img)
```

we identify that the square root transformation is the best choice.

We then fit a new linear model with the transformed dependent variable, **$\sqrt{LDL}$**:

$\mathbf{\sqrt{LDL}}$ ~ $\mathbf{age + race + gender + height + weight + BMI + fat + cholesterol + triglycerides + diastolic + systolic}$ (2)

As the model has as many as 11 covariates and some of them are insignificant under t-test, we then use the stepwise selection technique to choose variables that best explain **$\sqrt{LDL}$**. 

Besides, we consider transformations upon predictors. Considering partial residual plots:

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align="center", fig.cap="Partial Residual Plot"}
library(png)
library(grid)
img <- readPNG("./Huayuli/Partial.png")
 grid.raster(img)
```

we find out that variables **age** and **triglycerides** violate the linear structure assumption. Both of these plots exhibit a quadratic form, so in addition to response variables in the full model (2) above, we add **age^2^** and **triglycerides^2^** to the linear regression model:

$\mathbf{\sqrt{LDL}}$ ~ $\mathbf{age + age^2 + race + gender + height + weight + BMI + fat + cholesterol + triglycerides + triglycerides^2 + diastolic + systolic}$ (3)

Just as the process before, we will execute the stepwise model selection technique to choose the most significant variables of this model.

Steps outlined above are carried out in R, Stata and Python. In R, we use the package [data.table](https://cran.r-project.org/web/packages/data.table/index.html) for data cleaning.


# Core Analysis {.tabset}

```{r setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, error = FALSE)
```

## R

### Data Cleaning

```{r}
## Group Project HTML
## Author: Huayu Li, huayuli@umich.edu
## Updated: Dec. 8 2019

#### Data cleaning using data.table 

## Libraries: -------------------------------------------------------------------------
library(data.table)
library(foreign)
library(tidyverse) 

## 80: --------------------------------------------------------------------------------

## Read the datasets
demo=data.table(read.xport("./Original Data/DEMO_I.XPT.txt"))
tot1=data.table(read.xport("./Original Data/DR1TOT_I.XPT.txt"))
tot2=data.table(read.xport("./Original Data/DR2TOT_I.XPT.txt"))
b_pres=data.table(read.xport("./Original Data/BPX_I.XPT.txt"))
ldl=data.table(read.xport("./Original Data/TRIGLY_I.XPT.txt"))
measure=data.table(read.xport("./Original Data/BMX_I.XPT.txt"))

## For each dataset, choose the proper variables and make 
## some transformation.

# For demo dataset, we choose seqn, gender, age and race variables
Demo=demo[,.(seqn=SEQN,gender=as.factor(RIAGENDR),
             age=RIDAGEYR,race=as.factor(RIDRETH3))]

# For dietary data, we choose seqn, intake fat, intake cholesterol
# for each day. 
TOT1=tot1[,.(seqn=SEQN,intake_fat1=DR1TTFAT,
             intake_chol1=DR1TCHOL)]
TOT2=tot2[,.(seqn=SEQN,intake_fat2=DR2TTFAT,
             intake_chol2=DR2TCHOL)]

## Next we will use the average intake of the two days into
## our model. The average step is as following:
intake_type=c('intake_fat1','intake_fat2','intake_chol1','intake_chol2')
TOT=TOT1%>%merge(.,TOT2,by='seqn',all=FALSE)
TOT=melt(TOT,measure=intake_type)[
    ,.(seqn,type=factor(variable,intake_type,c(rep('intake_fat',times=2),
                                               rep('intake_chol',times=2))),
       variable,value)  
    ][
      ,.(intake=mean(value,na.rm=TRUE)),by=.(seqn,type)
    ]
  
TOT=dcast(TOT,...~type,value.var=c('intake'))  

# For blood pressure, we choose seqn, systolic pressures and diastolic 
# pressures. We then use the average pressure as the final pressure.
pres_type=c(paste('sys',1:4,sep=''),paste('dia',1:4,sep=''))
B_pres=b_pres[,.(seqn=SEQN,sys1=BPXSY1,sys2=BPXSY2,sys3=BPXSY3,sys4=BPXSY4,
                 dia1=BPXDI1,dia2=BPXDI2,dia3=BPXDI3,dia4=BPXDI4)]
B_pres=melt(B_pres,measure=pres_type)[,
                                      .(seqn,type=factor(variable,pres_type,
                                                         c(rep('s',times=4),rep('d',times=4))),
                                        variable,pressure=value)
                                      ][
                                        ,.(pres=mean(pressure,na.rm=TRUE)),by=.(seqn,type)
                                        ]
B_pres=dcast(B_pres,...~type,value.var=c('pres'))[
  ,.(seqn,systolic=s,diastolic=d)
  ]

# For ldl dataset, we choose seqn, LDL-cholesterol and Triglyceride
# for mg/dL.
LDL=ldl[,.(seqn=SEQN,ldl=LBDLDL,triglycerides=LBXTR)]

# For body measure dataset, we choose weight height and bmi as our 
# variables.
Measure=measure[,.(seqn=SEQN,weight=BMXWT,height=BMXHT,bmi=BMXBMI)]


## Now merge the datasets into one whole, with the seqn as
## the merging label. By the way, some seqn labels 
## should be removed, for they are not included in LDL dataset.

Data=Demo%>%merge(.,TOT,by='seqn',all=FALSE)%>%
  merge(.,B_pres,by='seqn',all=FALSE)%>%
  merge(.,LDL,by='seqn',all=FALSE)%>%
  merge(.,Measure,by='seqn',all=FALSE)%>%
  na.omit()

```

### Models

```{r}
### Using this file for regression: ---------------------------------------------------

## Libraries: -------------------------------------------------------------------------
library(lme4)
library(MASS)
library(car)

## 80: --------------------------------------------------------------------------------

## Remove the seqn variable, and set gender and race as factor variables
DT=Data[,.(gender=as.factor(gender),age,race=as.factor(race),intake_fat,intake_chol,
         systolic,diastolic,ldl,triglycerides,weight,height,bmi)]

## First of all, we will fit the model with all variables, and then give 
## the residual plot of the model.
L1=lm(ldl~.,data=DT)
summary(L1)
```

```{r eval = FALSE}
## Here we give the residual plot of the model
plot(L1$fitted.values,L1$residuals)

## Here, it seems that some transformations should be used upon ldl. Here
## we do the Box-Cox test.
boxcox(L1,plotit=TRUE,lambda=seq(0,1,1/100))
```

```{r}
## Here it seems that lambda=0.5 is the best choice, that is, to use sqrt(ldl).
## Here we make the transformation and then do the regression again.
L2=lm(sqrt(ldl)~.,data=DT)
summary(L2)

## There are too many variables in the regression model, so here we will do
## the model selection and choose the variables. Here we do both the forward
## and backward selections.
L3=step(L2,direction='both',trace=FALSE)
summary(L3)
```

From the output result, we find out that variables age, diastolic, triglycerides, weight, height are selected, and they are all significant under t-test. 

In this model, variables age, diastolic, triglycerides and weight are positive correlated to the fitted level of ldl, while height is negative correlated: with other variables fixed, one year of age increase leads to 0.008 unit increase in $\sqrt{ldl}$, and 1 unit diastolic increase leads to 0.02 unit increase in $\sqrt{ldl}$; 1 unit increase in triglycerides leads to 0.006 unit increase in $\sqrt{ldl}$, and for weight this will lead to 0.005 unit increase in $\sqrt{ldl}$; for height, this will lead to 0.008 unit decrease in $\sqrt{ldl}$. The $R^2$ is 0.1304, and the residual standard error is 1.603.

```{r eval=FALSE}
## By the way, in the models before, we didn't consider transformations 
## upon predictors; in the coming part, we will consider adding some
## nonlinear terms.
crPlots(L2,layout=c(4,3))
```

```{r}
## From the partial residual plots, we can find out that for triglycerides and age,
## some nonlinear transformation forms should be add. We add this term, and the
## regression result is as following:
L4=lm(sqrt(ldl)~gender+age+race+intake_fat+intake_chol+systolic+diastolic+
             weight+height+bmi+triglycerides+I(triglycerides^2)+I(age^2),data=DT)
summary(L4)

## Just the same, do the model selection.
L5=step(L4,direction='both',trace=FALSE)
summary(L5)

```

After model selection, we can find out that terms age, systolic, diastolic, weight, height, bmi, triglycerides, $triglycerides^2$ and $age^2$ are selected, and they are significant under t-test. The `height` `bmi` and the two square terms are negatively correlated with `ldl`, with other variables positively correlated with `ldl`. The residual standard error changes to 1.53, and the $R^2$ increases to 0.2085, which means that this model performs better than the one without square terms.


## Stata

### Data Cleaning
```{stata eval = FALSE}
* import demographic data
import sasxport "./Original Data/DEMO_I.XPT.txt", clear

* rename variables
rename riagendr gender
rename ridageyr age
rename ridreth3 race

* select variables of focus
keep seqn gender age race

* save the cleaned demographics data
save "./Xiru Lyu/Data/demo.dta", replace

* import diet (day 1) data
import sasxport "./Original Data/DR1TOT_I.XPT.txt", clear

* rename variables
rename dr1ttfat fat1
rename dr1tchol chol1

* select variables of interest
keep seqn fat1 chol1

* save the cleaned diet (day 1) dataset
save "./Xiru Lyu/Data/diet1.dta", replace

* import diet (day 2) data
import sasxport "./Original Data/DR2TOT_I.XPT.txt", clear

* rename variables
rename dr2ttfat fat2
rename dr2tchol chol2

* select variables of focus
keep seqn fat2 chol2

* save the cleaned diet (day 2) dataset
save "./Xiru Lyu/Data/diet2.dta", replace

* import LDL & triglyceride data
import sasxport "./Original Data/TRIGLY_I.XPT.txt", clear

* rename variables
rename lbdldl ldl
rename lbxtr triglyceride

* select variables of interest
keep seqn ldl trig

* save the cleaned cholesterol dataset
save "./Xiru Lyu/Data/ldl.dta", replace

* import blood pressure data
import sasxport "./Original Data/BPX_I.XPT.txt", clear

* rename variables
rename bpxsy1 sy1
rename bpxsy2 sy2
rename bpxsy3 sy3
rename bpxsy4 sy4
rename bpxdi1 di1
rename bpxdi2 di2
rename bpxdi3 di3
rename bpxdi4 di4

* compute averaged systolic and diastolic blood pressure for each participant
egen systolic = rowmean(sy1 sy2 sy3 sy4)
egen diastolic = rowmean(di1 di2 di3 di4)

* select variables of interest
keep seqn systolic diastolic

* save the cleaned blood pressure dataset
save "./Xiru Lyu/Data/bp.dta", replace

* import body measure data
import sasxport "./Original Data/BMX_I.XPT.txt", clear

* rename variables
rename bmxwt weight
rename bmxbmi bmi
rename bmxht height

* select variables of interest
keep seqn weight height bmi

* merge datasets by seqn
merge 1:1 seqn using "./Xiru Lyu/Data/demo.dta"
keep if _merge == 3
drop _merge
merge 1:1 seqn using "./Xiru Lyu/Data/diet1.dta"
keep if _merge == 3
drop _merge
merge 1:1 seqn using "./Xiru Lyu/Data/diet2.dta"
keep if _merge == 3
drop _merge
merge 1:1 seqn using "./Xiru Lyu/Data/bp.dta"
keep if _merge == 3
drop _merge
merge 1:1 seqn using "./Xiru Lyu/Data/ldl.dta"
keep if _merge == 3
drop _merge

* compute averaged intakes of fat and cholesterol
egen fat = rowmean(fat1 fat2)
egen chol = rowmean(chol1 chol2)

* drop extra columns
drop fat1 fat2 chol1 chol2

* drop rows with missing values
foreach var of varlist age bmi chol diastolic fat gender height ldl race ///
seqn systolic triglyceride weight{
drop if missing(`var')
}

* save the dataset for data analysis
save "./Xiru Lyu/Data/final.dta", replace
```

### Models

```{stata, eval = FALSE}
* transform the dependent variable
generate ldl2 = sqrt(ldl)

* fit a multiple linear regression model
regress ldl2 age i.race i.gender bmi weight height diastolic systolic chol ///
fat trig
```

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align="center", fig.cap="Regression Result of Full Model (2)"}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/full_1.png")
 grid.raster(img)
```

I first fitted the full model, including all possible covariates and the transformed dependent variable, and then I used forward and backward stepwise selections for model selections. To be consistent with the result produced by R, I used the result from the backward selection for later AIC/BIC comparison. 

```{stata, eval = FALSE}
* backward selection
xi: stepwise, pr(.1): regress ldl2 age i.race i.gender bmi weight height ///
diastolic systolic chol fat triglyceride
```

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align='center', fig.cap="Backward Selection Result of Full Model (2)"}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/backward_1.png")
 grid.raster(img)
```

```{stata, eval = FALSE}
* forward selection
xi: stepwise, pe(.1): regress ldl2 age i.race i.gender bmi weight height ///
diastolic systolioc chol fat triglyceride
```

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align='center', fig.cap='Forward Selection Result of Full Model (2)'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/forward_1.png")
 grid.raster(img)
```

```{stata, eval = FALSE}
* transform covariates
generate triglyceride2 = triglyceride^2
generate age2 = age^2

* fit a multiple linear regression model
regress ldl2 age age2 i.race i.gender bmi weight height diastolic systolic ///
chol fat triglyceride triglyceride2
```

I then fitted another model that contains two extra transformed independent variables. With the stepwise model selection procedure, I kept the model selected by the backward selection as the one for further AIC/BIC comparison so that my result is consistent with the result produced by R. 

```{r fig.width=5, fig.height=6,echo=FALSE, fig.align='center', fig.cap='Regression Result of Full Model (3)'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/full_2.png")
 grid.raster(img)
```

```{stata, eval = FALSE}
* backward selection
xi: stepwise, pr(.05): regress ldl2 age age2 i.race i.gender bmi weight  ///
height diastolic systolic chol fat triglyceride triglyceride2
```

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align='center', fig.cap='Backward Selection Result of Full Model (3)'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/backward_2.png")
 grid.raster(img)
```

```{stata, eval = FALSE}
* forward selection
xi: stepwise, pe(.05): regress ldl2 age age2 i.race i.gender bmi weight ///
height diastolic systolic chol fat triglyceride triglyceride2
```

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align='center', fig.cap='Forward Selection Result of Full Model (3)'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/backward_2.png")
 grid.raster(img)
```

```{stata, eval = FALSE}
* compare AIC & BIC of two nested models
regress ldl2 age height weight diastolic triglyceride
estat ic
```

```{r fig.width=5, fig.height=1,echo=FALSE, fig.align='center', fig.cap='AIC for Model 2_a'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/AIC_1.png")
 grid.raster(img)
```

```{stata, eval = FALSE}
regress ldl2 age age2 height weight bmi diastolic systolic triglyceride ///
triglyceride2
estat ic
```

```{r fig.width=5, fig.height=1,echo=FALSE, fig.align='center', fig.cap='AIC for Model 2_b'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/AIC_2.png")
 grid.raster(img)
```

A comparison for AIC/BIC for two nested models shows that the model $\mathbf{\sqrt{LDL}}$ ~ $\mathbf{age + age^2 + height + weight + BMI + triglyceride + triglyceride^2 + diastolic + systolic}$ is the better one. Inferential statistics for the model is produced below. Covariates age, triglyceride, weight, diastolic and systolic blood pressures are positively correlated with the level of LDL, while **$age^2$**, **$triglyceride^2$** and **BMI** are negatively correlated with the response variable.

Specifically, with other variables fixed, one year increase in age leads to approximately 0.10 unit of increase in $\sqrt{ldl}$. Also, the rate of increase for the level of $\sqrt{ldl}$ slows down as one ages. One unit of increase in diastolic blood pressure can increase $\sqrt{ldl}$ by 0.006 unit. One unit of increase in systolic blood pressure can increase $\sqrt{ldl}$ by 0.004 unit. One unit of increase in BMI decreases $\sqrt{ldl}$ by 0.075 unit. One unit of increase in weight and triglyceride can bump up $\sqrt{ldl}$ by .026 and .021 unit, respectively. Finally, one unit increase in height leads to approximately 0.026 unit of decrease in $\sqrt{ldl}$. 

## Python

```{r include=FALSE}
library(reticulate)
# py_install("pandas")
# py_install("numpy")
# py_install("sklearn")
# py_install("statsmodels")
# py_install("matplotlib")
# py_install("pylab")
use_virtualenv(virtualenv = "r-reticulate")
# use_python("/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7")
```

Note for Python, we use pandas to merge and clean all datasets. Because there is no package to perform stepwise model selection, so we refer outsource codes from the internet for stepwise selection by AIC. Links for reference are attached to code chunks below.

### Data Cleaning

```{python, message=FALSE, warning=FALSE}
import pandas as pd
import numpy as np
LDLdata=pd.read_sas(r'./Original Data/TRIGLY_I.XPT',encoding='utf8')
DR1=pd.read_sas(r'./Original Data/DR1TOT_I.XPT',encoding='utf8')
DR2=pd.read_sas(r'./Original Data/DR2TOT_I.XPT',encoding='utf8')
BPX=pd.read_sas(r'./Original Data/BPX_I.XPT',encoding='utf8')
DEMO=pd.read_sas(r'./Original Data/DEMO_I.XPT',encoding='utf8')
BMI=pd.read_sas(r'./Original Data/BMX_I.XPT',encoding='utf8')

LDL=LDLdata[['SEQN','LBXTR', 'LBDLDL']]#select cols
#WTSAF2YR:MEC weight
#LBXTR: triglyceride(mg/dl)
#LBDLDL:  LDL mg/dl

BloodP=BPX[['SEQN']]
BloodP['BPXSY']=np.nanmean(BPX[['BPXSY1','BPXSY2','BPXSY3','BPXSY4']],axis=1)#mean value omitting na value
BloodP['BPXDI']=np.nanmean(BPX[['BPXDI1','BPXDI2','BPXDI3','BPXDI4']],axis=1)


drday1=DR1[['SEQN','DR1TTFAT','DR1TCHOL']] #select cols
drday2=DR2[['SEQN','DR2TTFAT','DR2TCHOL']]
drboth=pd.merge(drday1,drday2,how='inner',on='SEQN')#merge table
drboth['FAT']=np.nanmean(drboth[['DR1TTFAT','DR2TTFAT']],axis=1)
drboth['CHOL']=np.nanmean(drboth[['DR1TCHOL','DR2TCHOL']],axis=1)
dr=drboth[['SEQN','FAT','CHOL']]
demo=DEMO[['SEQN','RIAGENDR','RIDAGEYR','RIDRETH3']]
#ID,GENDER,AGE,RACE(FACTOR)
demo.rename(columns={'RIAGENDR':'GENDER','RIDAGEYR':'AGE','RIDRETH3':'RACE'},inplace=True)#rename colnames
BMI=BMI[['SEQN','BMXHT','BMXWT','BMXBMI']]
#ID,HEIGHT,WEIGHT
BMI.columns=['SEQN','HEIGHT','WEIGHT','BMI']
#merge tables
Data=pd.merge(LDL,BloodP,how='inner',on='SEQN')
Data=pd.merge(Data,dr,how='inner',on='SEQN')
Data=pd.merge(Data,demo,how='inner',on='SEQN')
Data=pd.merge(Data,BMI,how='inner',on='SEQN')

Data=Data.dropna(axis=0)

Data.to_csv(r'Data1.csv',index=None)
#save table
```

### Modeling

```{python, message=FALSE, warning=FALSE}
import pandas as pd
import numpy as np
from sklearn import linear_model
from scipy import stats
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt
import pylab
import statsmodels.api as sm
```

```{python, include=FALSE}
## forward backward model selection code from github, link  https://github.com/talhahascelik/python_stepwiseSelection/blob/master/stepwiseSelection.py

#Copyright 2019 Sinan Talha Hascelik
#
#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.


def forwardSelection(X, y, model_type ="linear",elimination_criteria = "aic", varchar_process = "dummy_dropfirst", sl=0.05):
    """
    Forward Selection is a function, based on regression models, that returns significant features and selection iterations.\n
    Required Libraries: pandas, numpy, statmodels
    
    Parameters
    ----------
    X : Independent variables (Pandas Dataframe)\n
    y : Dependent variable (Pandas Series, Pandas Dataframe)\n
    model_type : 'linear' or 'logistic'\n
    elimination_criteria : 'aic', 'bic', 'r2', 'adjr2' or None\n
        'aic' refers Akaike information criterion\n
        'bic' refers Bayesian information criterion\n
        'r2' refers R-squared (Only works on linear model type)\n
        'r2' refers Adjusted R-squared (Only works on linear model type)\n
    varchar_process : 'drop', 'dummy' or 'dummy_dropfirst'\n
        'drop' drops varchar features\n
        'dummy' creates dummies for all levels of all varchars\n
        'dummy_dropfirst' creates dummies for all levels of all varchars, and drops first levels\n
    sl : Significance Level (default: 0.05)\n
    
    Returns
    -------
    columns(list), iteration_logs(str)\n\n
    Not Returns a Model
    
    Tested On
    ---------
    Python v3.6.7, Pandas v0.23.4, Numpy v1.15.04, StatModels v0.9.0
    
    See Also
    --------
    https://en.wikipedia.org/wiki/Stepwise_regression
    """
    X = __varcharProcessing__(X,varchar_process = varchar_process)
    return __forwardSelectionRaw__(X, y, model_type = model_type,elimination_criteria = elimination_criteria , sl=sl)
    
def backwardSelection(X, y, model_type ="linear",elimination_criteria = "aic", varchar_process = "dummy_dropfirst", sl=0.05):
    """
    Backward Selection is a function, based on regression models, that returns significant features and selection iterations.\n
    Required Libraries: pandas, numpy, statmodels
    
    Parameters
    ----------
    X : Independent variables (Pandas Dataframe)\n
    y : Dependent variable (Pandas Series, Pandas Dataframe)\n
    model_type : 'linear' or 'logistic'\n
    elimination_criteria : 'aic', 'bic', 'r2', 'adjr2' or None\n
        'aic' refers Akaike information criterion\n
        'bic' refers Bayesian information criterion\n
        'r2' refers R-squared (Only works on linear model type)\n
        'r2' refers Adjusted R-squared (Only works on linear model type)\n
    varchar_process : 'drop', 'dummy' or 'dummy_dropfirst'\n
        'drop' drops varchar features\n
        'dummy' creates dummies for all levels of all varchars\n
        'dummy_dropfirst' creates dummies for all levels of all varchars, and drops first levels\n
    sl : Significance Level (default: 0.05)\n
    
    Returns
    -------
    columns(list), iteration_logs(str)\n\n
    Not Returns a Model
    
    Tested On
    ---------
    Python v3.6.7, Pandas v0.23.4, Numpy v1.15.04, StatModels v0.9.0
    
    See Also
    --------
    https://en.wikipedia.org/wiki/Stepwise_regression    
    """
    X = __varcharProcessing__(X,varchar_process = varchar_process)
    return __backwardSelectionRaw__(X, y, model_type = model_type,elimination_criteria = elimination_criteria , sl=sl)

def __varcharProcessing__(X, varchar_process = "dummy_dropfirst"):
    
    dtypes = X.dtypes
    if varchar_process == "drop":   
        X = X.drop(columns = dtypes[dtypes == np.object].index.tolist())
        print("Character Variables (Dropped):", dtypes[dtypes == np.object].index.tolist())
    elif varchar_process == "dummy":
        X = pd.get_dummies(X,drop_first=False)
        print("Character Variables (Dummies Generated):", dtypes[dtypes == np.object].index.tolist())
    elif varchar_process == "dummy_dropfirst":
        X = pd.get_dummies(X,drop_first=True)
        print("Character Variables (Dummies Generated, First Dummies Dropped):", dtypes[dtypes == np.object].index.tolist())
    else: 
        X = pd.get_dummies(X,drop_first=True)
        print("Character Variables (Dummies Generated, First Dummies Dropped):", dtypes[dtypes == np.object].index.tolist())
    
    X["intercept"] = 1
    cols = X.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    X = X[cols]
    
    return X

def __forwardSelectionRaw__(X, y, model_type ="linear",elimination_criteria = "aic", sl=0.05):

    iterations_log = ""
    cols = X.columns.tolist()
    
    def regressor(y,X, model_type=model_type):
        if model_type == "linear":
            regressor = sm.OLS(y, X).fit()
        elif model_type == "logistic":
            regressor = sm.Logit(y, X).fit()
        else:
            print("\nWrong Model Type : "+ model_type +"\nLinear model type is seleted.")
            model_type = "linear"
            regressor = sm.OLS(y, X).fit()
        return regressor
    
    selected_cols = ["intercept"]
    other_cols = cols.copy()
    other_cols.remove("intercept")
    
    model = regressor(y, X[selected_cols])
    
    if elimination_criteria == "aic":
        criteria = model.aic
    elif elimination_criteria == "bic":
        criteria = model.bic
    elif elimination_criteria == "r2" and model_type =="linear":
        criteria = model.rsquared
    elif elimination_criteria == "adjr2" and model_type =="linear":
        criteria = model.rsquared_adj
    
    
    for i in range(X.shape[1]):
        pvals = pd.DataFrame(columns = ["Cols","Pval"])
        for j in other_cols:
            model = regressor(y, X[selected_cols+[j]])
            pvals = pvals.append(pd.DataFrame([[j, model.pvalues[j]]],columns = ["Cols","Pval"]),ignore_index=True)
        pvals = pvals.sort_values(by = ["Pval"]).reset_index(drop=True)
        pvals = pvals[pvals.Pval<=sl]
        if pvals.shape[0] > 0:
            
            model = regressor(y, X[selected_cols+[pvals["Cols"][0]]])
            iterations_log += str("\nEntered : "+pvals["Cols"][0] + "\n")    
            iterations_log += "\n\n"+str(model.summary())+"\nAIC: "+ str(model.aic) + "\nBIC: "+ str(model.bic)+"\n\n"
                    
        
            if  elimination_criteria == "aic":
                new_criteria = model.aic
                if new_criteria < criteria:
                    print("Entered :", pvals["Cols"][0], "\tAIC :", model.aic)
                    selected_cols.append(pvals["Cols"][0])
                    other_cols.remove(pvals["Cols"][0])
                    criteria = new_criteria
                else:
                    print("break : Criteria")
                    break
            elif  elimination_criteria == "bic":
                new_criteria = model.bic
                if new_criteria < criteria:
                    print("Entered :", pvals["Cols"][0], "\tBIC :", model.bic)
                    selected_cols.append(pvals["Cols"][0])
                    other_cols.remove(pvals["Cols"][0])
                    criteria = new_criteria
                else:
                    print("break : Criteria")
                    break        
            elif  elimination_criteria == "r2" and model_type =="linear":
                new_criteria = model.rsquared
                if new_criteria > criteria:
                    print("Entered :", pvals["Cols"][0], "\tR2 :", model.rsquared)
                    selected_cols.append(pvals["Cols"][0])
                    other_cols.remove(pvals["Cols"][0])
                    criteria = new_criteria
                else:
                    print("break : Criteria")
                    break           
            elif  elimination_criteria == "adjr2" and model_type =="linear":
                new_criteria = model.rsquared_adj
                if new_criteria > criteria:
                    print("Entered :", pvals["Cols"][0], "\tAdjR2 :", model.rsquared_adj)
                    selected_cols.append(pvals["Cols"][0])
                    other_cols.remove(pvals["Cols"][0])
                    criteria = new_criteria
                else:
                    print("Break : Criteria")
                    break
            else:
                print("Entered :", pvals["Cols"][0])
                selected_cols.append(pvals["Cols"][0])
                other_cols.remove(pvals["Cols"][0])            
                
        else:
            print("Break : Significance Level")
            break
        
    model = regressor(y, X[selected_cols])
    if elimination_criteria == "aic":
        criteria = model.aic
    elif elimination_criteria == "bic":
        criteria = model.bic
    elif elimination_criteria == "r2" and model_type =="linear":
        criteria = model.rsquared
    elif elimination_criteria == "adjr2" and model_type =="linear":
        criteria = model.rsquared_adj
    
    print(model.summary())
    print("AIC: "+str(model.aic))
    print("BIC: "+str(model.bic))
    print("Final Variables:", selected_cols)

    return selected_cols, iterations_log

def __backwardSelectionRaw__(X, y, model_type ="linear",elimination_criteria = "aic", sl=0.05):
    
    iterations_log = ""
    last_eleminated = ""    
    cols = X.columns.tolist()

    def regressor(y,X, model_type=model_type):
        if model_type =="linear":
            regressor = sm.OLS(y, X).fit()
        elif model_type == "logistic":
            regressor = sm.Logit(y, X).fit()
        else:
            print("\nWrong Model Type : "+ model_type +"\nLinear model type is seleted.")
            model_type = "linear"
            regressor = sm.OLS(y, X).fit()
        return regressor
    for i in range(X.shape[1]):
        if i != 0 :          
            if elimination_criteria == "aic":
                criteria = model.aic
                new_model = regressor(y,X)
                new_criteria = new_model.aic
                if criteria < new_criteria:
                    print("Regained : ", last_eleminated)
                    iterations_log += "\n"+str(new_model.summary())+"\nAIC: "+ str(new_model.aic) + "\nBIC: "+ str(new_model.bic)+"\n"
                    iterations_log += str("\n\nRegained : "+last_eleminated + "\n\n")
                    break  
            elif elimination_criteria == "bic":
                criteria = model.bic
                new_model = regressor(y,X)
                new_criteria = new_model.bic
                if criteria < new_criteria:
                    print("Regained : ", last_eleminated)
                    iterations_log += "\n"+str(new_model.summary())+"\nAIC: "+ str(new_model.aic) + "\nBIC: "+ str(new_model.bic)+"\n"
                    iterations_log += str("\n\nRegained : "+last_eleminated + "\n\n")
                    break  
            elif elimination_criteria == "adjr2" and model_type =="linear":
                criteria = model.rsquared_adj
                new_model = regressor(y,X)
                new_criteria = new_model.rsquared_adj
                if criteria > new_criteria:
                    print("Regained : ", last_eleminated)
                    iterations_log += "\n"+str(new_model.summary())+"\nAIC: "+ str(new_model.aic) + "\nBIC: "+ str(new_model.bic)+"\n"
                    iterations_log += str("\n\nRegained : "+last_eleminated + "\n\n")
                    break  
            elif elimination_criteria == "r2" and model_type =="linear":
                criteria = model.rsquared
                new_model = regressor(y,X)
                new_criteria = new_model.rsquared
                if criteria > new_criteria:
                    print("Regained : ", last_eleminated)
                    iterations_log += "\n"+str(new_model.summary())+"\nAIC: "+ str(new_model.aic) + "\nBIC: "+ str(new_model.bic)+"\n"
                    iterations_log += str("\n\nRegained : "+last_eleminated + "\n\n")
                    break   
            else: 
                new_model = regressor(y,X)
            model = new_model
            iterations_log += "\n"+str(model.summary())+"\nAIC: "+ str(model.aic) + "\nBIC: "+ str(model.bic)+"\n"
        else:
            model = regressor(y,X)
            iterations_log += "\n"+str(model.summary())+"\nAIC: "+ str(model.aic) + "\nBIC: "+ str(model.bic)+"\n"
        maxPval = max(model.pvalues)
        cols = X.columns.tolist()
        if maxPval > sl:
            for j in cols:
                if (model.pvalues[j] == maxPval):
                    print("Eliminated :" ,j)
                    iterations_log += str("\n\nEliminated : "+j+ "\n\n")
                    
                    del X[j]
                    last_eleminated = j
        else:
            break
    print(str(model.summary())+"\nAIC: "+ str(model.aic) + "\nBIC: "+ str(model.bic))
    print("Final Variables:", cols)
    iterations_log += "\n"+str(model.summary())+"\nAIC: "+ str(model.aic) + "\nBIC: "+ str(model.bic)+"\n"
    return cols, iterations_log
```
```{python}
Data=pd.read_csv(r'Data1.csv')#read table
Data=Data.drop(['SEQN'],axis=1)#drop the id variable 'SEQN' 
#python seems has no direct code to deal factor variables like R
RACE=pd.get_dummies(Data['RACE'])
RACENAME=['Mexican American','Other Hispanic','Non-Hispanic White','Non-Hispanic Black','Non-Hispanic Asian','Other Race']
RACE.columns=[ i for i in RACENAME]
RACE=RACE.drop(['Mexican American'],axis=1)

GENDER=pd.get_dummies(Data['GENDER'])
gendername=['Male','Female']
GENDER.columns=[i for i in gendername]
GENDER=GENDER.drop(['Male'],axis=1)

Data=Data.drop(['GENDER','RACE'],axis=1)
Data=pd.concat([Data,GENDER,RACE],axis=1)

y1=Data[['LBDLDL']]       ## lm reg, the response= LBDLDL (LDL)
x1=Data.drop(['LBDLDL'],axis=1) # others except LDL are the variables
x1=sm.add_constant(x1)     ## add intercept, for python, add 1 colunms by hand

lm1=sm.OLS(y1.astype(float),x1.astype(float)).fit() # OLS y on X+1

lm1.summary()     # coefficient table

```

```{python}
#plot residual vesus y-fitted
res1=lm1.resid
y1_fit=lm1.predict(x1)
fig1=plt.figure(figsize=(8,6))
plt.plot(y1_fit,res1,'o''c') #'0' means dots,''''means no line between dots, 'c' color
plt.title('Residuals against Y-fited')
plt.ylabel('Residuals')
plt.xlabel('Y-fitted value')
plt.show()
```

```{python, eval = FALSE}
res = lm1.resid  # residuals
stats.probplot(res, dist="norm", plot=pylab) # QQplot, simliar to fig = sm.qqplot(res)
pylab.show()
```

```{r fig.width=6, fig.height=6,echo=FALSE, fig.align="left", fig.cap="Probability Plot"}
library(png)
library(grid)
img <- readPNG("./kaliu python/failed picture in R markdwon/38.png")
 grid.raster(img)
```


First, we graph the QQ-plot of residuals, and we can see errors deviate a bit from the normality assumption.

```{python}
# boxcox
y2=np.array(y1).flatten() #get pandas col as list(like vector in R)
fig2=plt.figure()
ax = fig2.add_subplot(111)
#plot boxcox
prob=stats.boxcox_normplot(y2,0,1,plot=ax)
_, maxlog=stats.boxcox(y2)
ax.axvline(maxlog,color='r')
plt.show()
```

From the plot, we can transform the response to $y^\lambda$, and the result seems the best when lambda is around 0.4. For simplicity, we pick $\lambda=0.5$.

```{python}
Data['LDL']=(Data[['LBDLDL']])**0.5 # transform the y value to y**0.5 as picked 
Data=Data.drop(['LBDLDL'],axis=1)

y3=Data[['LDL']]
x3=Data.drop(['LDL'],axis=1)
#select model
final_vars,_=forwardSelection(x3,y3,model_type='linear',elimination_criteria='aic')

final_vars,_=backwardSelection(x3,y3,model_type='linear',elimination_criteria='aic')
```

```{python include=FALSE}
#plot ccpr with varibles selected
x4=Data[['LBXTR', 'BPXDI', 'AGE', 'HEIGHT', 'WEIGHT']]
x4=sm.add_constant(x4)
lm2=sm.OLS(y3.astype(float),x4.astype(float)).fit()
for i in range(5):
    name=x4.columns[i+1]
    sm.graphics.plot_ccpr(lm2,name) 
    #https://en.wikipedia.org/wiki/Partial_residual_plot  
    #The CCPR (component and component-plus-residual) plot is a refinement of the partial residual plot
plt.show()
```

```{r fig.width=5.5, fig.height=5.5,echo=FALSE, fig.align="left"}
library(png)
library(grid)
img <- readPNG("./kaliu python/failed picture in R markdwon/43-1.png")
 grid.raster(img)
```

```{r fig.width=5.5, fig.height=5.5,echo=FALSE, fig.align="left"}
library(png)
library(grid)
img <- readPNG("./kaliu python/failed picture in R markdwon/43-2.png")
 grid.raster(img)
```

```{r fig.width=5.5, fig.height=5.5,echo=FALSE, fig.align="left"}
library(png)
library(grid)
img <- readPNG("./kaliu python/failed picture in R markdwon/43-3.png")
 grid.raster(img)
```

```{r fig.width=5.5, fig.height=5.5,echo=FALSE, fig.align="left"}
library(png)
library(grid)
img <- readPNG("./kaliu python/failed picture in R markdwon/43-4.png")
 grid.raster(img)
```

```{r fig.width=5.5, fig.height=5.5,echo=FALSE, fig.align="left"}
library(png)
library(grid)
img <- readPNG("./kaliu python/failed picture in R markdwon/43-5.png")
 grid.raster(img)
```

From graphs above, we can see that in LBXTR and AGE plots, there is a little inverse 'U' shape. Thus, in the final model, we add $LBXTR^2$ and $AGE^2$ terms.

```{python}
Data['AGE2']=Data[['AGE']]*Data[['AGE']]
Data['LBXTR2']=Data[['LBXTR']]*Data[['LBXTR']]
y5=Data[['LDL']]
x5=Data.drop(['LDL'],axis=1)
#add new variables and reslect model
final_vars,_=forwardSelection(x5,y5,model_type='linear',elimination_criteria='aic')

final_vars,_=backwardSelection(x5,y5,model_type='linear',elimination_criteria='aic')
```

From model selection by AIC, we select variables 'LBXTR', 'BPXSY', 'BPXDI', 'AGE', 'HEIGHT', 'WEIGHT', 'BMI', 'RACE', 'AGE2', 'LBXTR2'

```{python}
#part of race as selected, it is little strange to put part varibles in, so I put all the race varaibles in the final model, and my model may little differ from my groups
y=Data[['LDL']]
x=Data[['LBXTR', 'BPXSY', 'BPXDI', 'AGE', 'HEIGHT', 'WEIGHT', 'BMI','Other Hispanic','Non-Hispanic White','Non-Hispanic Black','Non-Hispanic Asian','Other Race', 'AGE2', 'LBXTR2']]
#here we add all RACE types except RACE='Mexican American', which is viewed as base

#reg and see final selected model coeffs
x=sm.add_constant(x)
lm_final=sm.OLS(y.astype(float),x.astype(float)).fit()
lm_final.summary()

```




# Additional Analysis {.tabset}

## R

```{r}
## Additional Analysis: Some extra graphs

## Libraries: -------------------------------------------------------------------------
library(ggplot2)
library(gridExtra)

## 80: --------------------------------------------------------------------------------

```


### Graphing

```{r}
## Graph 1: Some Diagnosis upon these models
### F1: Checking error assumptions--residual plots
R1=data.table(fitted_values=L2$fitted.values,residuals=L2$residuals)
R2=data.table(fitted_values=L3$fitted.values,residuals=L3$residuals)
R3=data.table(fitted_values=L4$fitted.values,residuals=L4$residuals)
R4=data.table(fitted_values=L5$fitted.values,residuals=L5$residuals)
rs1=ggplot(R1,aes(x=fitted_values,y=residuals))+geom_point(size=1,colour='blue')+
  labs(title='Model 1')
rs2=ggplot(R2,aes(x=fitted_values,y=residuals))+geom_point(size=1,colour='blue')+
  labs(title='Model 2')
rs3=ggplot(R3,aes(x=fitted_values,y=residuals))+geom_point(size=1,colour='blue')+
  labs(title='Model 3')
rs4=ggplot(R4,aes(x=fitted_values,y=residuals))+geom_point(size=1,colour='blue')+
  labs(title='Model 4') 
grid.arrange(rs1,rs2,rs3,rs4,nrow=2)
  
## Graph 2: QQ-plots of the models
par(mfrow=c(2,2))
qqnorm(R1$residuals, ylab="Residuals",main='Q-Q Plot of Model 1')
qqline(R1$residuals)
qqnorm(R2$residuals, ylab="Residuals",main='Q-Q Plot of Model 2')
qqline(R2$residuals)
qqnorm(R3$residuals, ylab="Residuals",main='Q-Q Plot of Model 3')
qqline(R3$residuals)
qqnorm(R4$residuals, ylab="Residuals",main='Q-Q Plot of Model 4')
qqline(R4$residuals)

## Graph 3: Partial Residual Plots upon Model 3 and 4
crPlots(L4,layout=c(3,3))
crPlots(L5)

## Graph 4: Relationships between ldl and gender/race.  We have the mean level of
## ldl between different gender and race (For CI, we will use the JackKnife 
## standard error.)
Mean_JK = function(x){
  lx=length(x)
  MX=matrix(rep(x,rep(lx-1,lx)),ncol=lx,byrow=TRUE)
  theta=colMeans(MX)
  mean_theta=mean(theta)
  std_theta={(lx-1)/lx*sum((theta-mean_theta)^2)}^(1/2)
  std_theta
}

Gend=DT[,.(gender,ldl)]
Race=DT[,.(race,ldl)]
MG=Gend[,.(mean_ldl=mean(ldl),l_ldl=mean(ldl)+qnorm(0.025)*Mean_JK(ldl),
           r_ldl=mean(ldl)+qnorm(0.975)*Mean_JK(ldl)),by=gender]
MR=Race[,.(mean_ldl=mean(ldl),l_ldl=mean(ldl)+qnorm(0.025)*Mean_JK(ldl),
           r_ldl=mean(ldl)+qnorm(0.975)*Mean_JK(ldl)),by=race]

gend=ggplot(Gend,aes(x=gender,y=ldl))+geom_point(size=1,colour='blue')+
  labs(title='ldl~gender')
race=ggplot(Race,aes(x=race,y=ldl))+geom_point(size=1,colour='blue')+
  labs(title='ldl~race') 
mean_gend=ggplot(MG,aes(x=gender,y=mean_ldl))+geom_point(shape=16,col='red')+
  geom_segment(data=MG,mapping=aes(x=gender,xend=gender,y=l_ldl,yend=r_ldl),
               col='blue')+
  labs(title = 'Mean level of ldl between genders')
mean_race=ggplot(MR,aes(x=race,y=mean_ldl))+geom_point(shape=16,col='red')+
  geom_segment(data=MR,mapping=aes(x=race,xend=race,y=l_ldl,yend=r_ldl),
               col='blue')+
  labs(title = 'Mean level of ldl between races')

grid.arrange(gend,race,mean_gend,mean_race,nrow=2)
```

Here we plot residual plots and QQ-plots, and the result shows that the fitted model satisfies assumptions for the OLS model. In addition, we plot relationships between ldl and gender and race, and plots show that the ldl level of males is slightly higher than females, when fixing other variables. For race, the ldl level of Other Race is the highest from the whole, and for Non-Hispanic Black is the lowest.

### Linear mixed model

```{r}
## Before graphing, we will have the linear mixed model upon the dataset:
LM=lmer(ldl~age+intake_fat+intake_chol+systolic+diastolic+
          weight+height+bmi+triglycerides+(1|gender)+(1|race),data=DT)
summary(LM)
```
  
Addutionally, I fitted a mixed effect model, having gender and race as random intercepts. The amount of variation explained by these two effects is roughly 0.006%, implying that the linear mixed model doesn't work well.

## Stata
I am interested in exploring the specific relationship between the level of triglyceride and the response varaiable $\sqrt{ldl}$. In partcular, does the relationship varies with the specific quantile of triglyceride? I used quantile regression to find the answer. 

```{stata, eval = FALSE}
qreg ldl2 triglyceride, quantile(0.05)
qreg ldl2 triglyceride, quantile(0.25)
qreg ldl2 triglyceride, quantile(0.5)
qreg ldl2 triglyceride, quantile(0.75)
qreg ldl2 triglyceride, quantile(0.90)
```

```{r fig.width=7, fig.height=2,echo=FALSE, fig.align='center'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/5.png")
 grid.raster(img)
```

```{r fig.width=7, fig.height=2,echo=FALSE, fig.align='center'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/25.png")
 grid.raster(img)
```

```{r fig.width=7, fig.height=2,echo=FALSE, fig.align='center'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/50.png")
 grid.raster(img)
```

```{r fig.width=7, fig.height=2,echo=FALSE, fig.align='center'}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/75.png")
 grid.raster(img)
```

```{r fig.width=7, fig.height=2,echo=FALSE, fig.align='center', fig.cap="Quantile Regression Results"}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/90.png")
 grid.raster(img)
```

```{r fig.width=5, fig.height=5,echo=FALSE, fig.align='center', fig.cap="Quantile Regression Plot"}
library(png)
library(grid)
img <- readPNG("./Xiru Lyu/Results/quantile.png")
 grid.raster(img)
```

The quantile plot above shows that the level of triglyceride has positive correlation with the $\sqrt{ldl}$ and the relationship between the two doesn't vary much by quantile. Also, note that the quantile plot is generated with R and a detailed script is located under the folder /Xiru Lyu/quantile.R.

## Python

```{python}
# additional analysis
#quantile regression: sqrt(LDL)~AGE
mod=smf.quantreg('LDL~AGE',Data)
quantiles = np.arange(.05, .95, .1)#ser quantile level
def fit_model(q):   #def  a quantile regression function
    res = mod.fit(q=q)
    return [q, res.params['Intercept'], res.params['AGE']] + \
            res.conf_int().loc['AGE'].tolist()

models = [fit_model(x) for x in quantiles]
#set columns for quantile interception slope CI(lower_bound,up_bound)
models = pd.DataFrame(models, columns=['q', 'a', 'b', 'lower_b', 'upper_b'])

ols = smf.ols('LDL ~ AGE', Data).fit()  #normal reg 
ols_ci = ols.conf_int().loc['AGE'].tolist()
ols = dict(a = ols.params['Intercept'],
           b = ols.params['AGE'],
           lower_b = ols_ci[0],  # Ci for b,lowerbound
           upper_b = ols_ci[1])  #CI for b, upbound

print(models)

#plot quantile fig line by line
x = np.arange(Data.AGE.min(), Data.AGE.max()+1, 1)
get_y = lambda a, b: a + b * x

fig, ax = plt.subplots(figsize=(8, 6))
y = get_y(models.a[0], models.b[0])
ax.plot(x, y, linestyle='dotted', color='c',label='tau=0.05')
y = get_y(models.a[1], models.b[1])
ax.plot(x, y, linestyle='dotted', color='g',label='tau=0.15')
y = get_y(models.a[2], models.b[2])
ax.plot(x, y, linestyle='dotted', color='b',label='tau=0.25')
y = get_y(models.a[3], models.b[3])
ax.plot(x, y, linestyle='dotted', color='c',label='tau=0.35')
y = get_y(models.a[4], models.b[4])
ax.plot(x, y, linestyle='dotted', color='g',label='tau=0.45')
y = get_y(models.a[5], models.b[5])
ax.plot(x, y, linestyle='dotted', color='b',label='tau=0.55')
y = get_y(models.a[6], models.b[6])
ax.plot(x, y, linestyle='dotted', color='c',label='tau=0.65')
y = get_y(models.a[7], models.b[7])
ax.plot(x, y, linestyle='dotted', color='g',label='tau=0.75')
y = get_y(models.a[8], models.b[8])
ax.plot(x, y, linestyle='dotted', color='b',label='tau=0.85')


y = get_y(ols['a'], ols['b'])

ax.plot(x, y, color='red', label='OLS')
ax.scatter(Data.AGE, Data.LDL, alpha=.2)
ax.set_xlim((10, 85))
ax.set_ylim((3.0, 17.5))
legend = ax.legend()
ax.set_xlabel('AGE', fontsize=16)
ax.set_ylabel('LDL(sqrt_LDL)', fontsize=16);
plt.show()
```

I would like to see if there is any specific relationship between the level of LDL and age. As demonstrated by the plot of the quantile regression, regression lines for different quantiles are roughly parallel, suggesting that the variance of the response variable is constant across values of age.


# Discussion

All of the three tools above use the stepwise model selection technique to choose the best fitted model, but there are some differences existing among these tools.

For the tool using `data.table` in R, the model selection function is just as `step(,direction='')`, and the direction choose is `both`; note that the selection criterion is by AIC. For Stata, the model selection technique is performed using `stepwise`, and the selection criterion is based on p-values. As Stata cannot perform the stepwise selection in both directions, separate forward and backward selections are performed, and p-values are tuned so that model selection results match those by R. For Python, the code for backward and forward selections are downloaded from the given Github site, and the selection criteria is by AIC. As the model selection technique differs for Python in selecting categorical variables of multiple levels, the final regression results by Python are slightly different from those by R and Stata.

# Results

To conclude, age, systolic, diastolic, weight, height, bmi, triglycerides, $triglyceride^2$, $age^2$ are significant predictors that affect the level of ldl. Specifically, age, systolic, diastolic,weight and triglycerides have positive correlations with the response, while height and bmi have negative relationships. For triglyceride and age, as they increase, the rate of increase for $\sqrt{ldl}$ becomes slowly.